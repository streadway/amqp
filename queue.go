// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Source code and contact info at http://github.com/streadway/amqp

package amqp

func (me *Queue) Declare(lifetime Lifetime, exclusive bool, noWait bool, arguments Table) (state QueueState, err error) {
	if err = me.channel.send(&queueDeclare{
		Queue:      me.name,
		Passive:    false,
		Durable:    lifetime.durable(),
		AutoDelete: lifetime.autoDelete(),
		Exclusive:  exclusive,
		NoWait:     noWait,
		Arguments:  arguments,
	}); err != nil {
		return
	}

	if !noWait {
		switch ok := (<-me.channel.rpc).(type) {
		case *queueDeclareOk:
			return QueueState{
				Declared:      true,
				MessageCount:  int(ok.MessageCount),
				ConsumerCount: int(ok.ConsumerCount),
			}, nil
		case nil:
			return QueueState{Declared: false}, me.channel.Close()
		default:
			return QueueState{Declared: false}, ErrBadProtocol
		}
	}

	return QueueState{Declared: true}, nil
}

func (me *Queue) Inspect() (state QueueState, err error) {
	if err = me.channel.send(&queueDeclare{
		Queue:   me.name,
		Passive: true,
	}); err != nil {
		return
	}

	switch ok := (<-me.channel.rpc).(type) {
	case *queueDeclareOk:
		return QueueState{
			Declared:      true,
			MessageCount:  int(ok.MessageCount),
			ConsumerCount: int(ok.ConsumerCount),
		}, nil
		// TODO: handle when it's not declared?
	case nil:
		return QueueState{Declared: false}, me.channel.Close()
	default:
		return QueueState{Declared: false}, ErrBadProtocol
	}

	panic("unreachable")
}

func (me *Queue) Bind(routingKey string, sourceExchange string, noWait bool, arguments Table) (err error) {
	if err = me.channel.send(&queueBind{
		Queue:      me.name,
		Exchange:   sourceExchange,
		RoutingKey: routingKey,
		NoWait:     noWait,
		Arguments:  arguments,
	}); err != nil {
		return
	}

	if !noWait {
		switch (<-me.channel.rpc).(type) {
		case *queueBindOk:
			return
		case nil:
			return me.channel.Close()
		default:
			return ErrBadProtocol
		}
	}

	return
}

func (me *Queue) Unbind(routingKey string, sourceExchange string, arguments Table) (err error) {
	if err = me.channel.send(&queueUnbind{
		Queue:      me.name,
		Exchange:   sourceExchange,
		RoutingKey: routingKey,
		Arguments:  arguments,
	}); err != nil {
		return
	}

	switch (<-me.channel.rpc).(type) {
	case *queueUnbindOk:
		return
	case nil:
		return me.channel.Close()
	default:
		return ErrBadProtocol
	}

	panic("unreachable")
}

func (me *Queue) Purge(noWait bool) (messageCount int, err error) {
	if err = me.channel.send(&queuePurge{
		Queue:  me.name,
		NoWait: noWait,
	}); err != nil {
		return
	}

	if !noWait {
		switch ok := (<-me.channel.rpc).(type) {
		case *queuePurgeOk:
			return int(ok.MessageCount), nil
		case nil:
			return 0, me.channel.Close()
		default:
			return 0, ErrBadProtocol
		}
	}

	return
}

func (me *Queue) Delete(ifUnused bool, ifEmpty bool, noWait bool) (err error) {
	if err = me.channel.send(&queueDelete{
		Queue:    me.name,
		IfUnused: ifUnused,
		IfEmpty:  ifEmpty,
		NoWait:   noWait,
	}); err != nil {
		return
	}

	if !noWait {
		switch (<-me.channel.rpc).(type) {
		case *queueDeleteOk:
			return
		case nil:
			return me.channel.Close()
		default:
			return ErrBadProtocol
		}
	}

	return
}

// Will deliver on the channel passed or this will make a new channel. The
// delivery channel, either provided or created, will be returned.
//
// If a consumerTag is not provided, the server will generate one. If you do
// include noWait, a random tag will be generated by the client.
func (me *Queue) Consume(noAck bool, exclusive bool, noLocal bool, noWait bool, consumerTag string, arguments Table, deliveries chan Delivery) (ch chan Delivery, err error) {
	ch = deliveries
	if ch == nil {
		ch = make(chan Delivery)
	}

	// when we won't wait for the server, add the consumer channel now
	if noWait {
		consumerTag = me.channel.addConsumer(consumerTag, ch)
	}

	if err = me.channel.send(&basicConsume{
		Queue:       me.name,
		ConsumerTag: consumerTag,
		NoLocal:     noLocal,
		NoAck:       noAck,
		Exclusive:   exclusive,
		NoWait:      noWait,
		Arguments:   arguments,
	}); err != nil {
		return
	}

	if !noWait {
		switch ok := (<-me.channel.rpc).(type) {
		case *basicConsumeOk:
			me.channel.addConsumer(ok.ConsumerTag, ch)
			return
		case nil:
			return ch, me.channel.Close()
		default:
			return ch, ErrBadProtocol
		}
	}

	return
}

// Convienence for when you want to publish a message through the default exchange with the routing
// key set to this queue name.  This is exactly the same as:
//
//   channel.E("").Publish("name-of-queue", mandatory, immediate, msg)
//
func (me *Queue) Publish(mandatory bool, immediate bool, msg Publishing) (err error) {
	return me.channel.E("").Publish(me.name, mandatory, immediate, msg)
}
